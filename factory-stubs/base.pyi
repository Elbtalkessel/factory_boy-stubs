from . import errors
from _typeshed import Incomplete
from typing import Generic, TypeVar

logger: Incomplete
T = TypeVar('T')

def get_factory_bases(bases): ...
def resolve_attribute(name, bases, default: Incomplete | None = None): ...

class FactoryMetaClass(type):
    def __call__(cls, **kwargs): ...
    def __new__(mcs, class_name, bases, attrs): ...

class BaseMeta:
    abstract: bool
    strategy: Incomplete

class OptionDefault:
    name: Incomplete
    value: Incomplete
    inherit: Incomplete
    checker: Incomplete
    def __init__(self, name, value, inherit: bool = False, checker: Incomplete | None = None) -> None: ...
    def apply(self, meta, base_meta): ...

class FactoryOptions:
    factory: Incomplete
    base_factory: Incomplete
    base_declarations: Incomplete
    parameters: Incomplete
    parameters_dependencies: Incomplete
    pre_declarations: Incomplete
    post_declarations: Incomplete
    counter_reference: Incomplete
    def __init__(self) -> None: ...
    @property
    def declarations(self): ...
    model: Incomplete
    abstract: bool
    def contribute_to_class(self, factory, meta: Incomplete | None = None, base_meta: Incomplete | None = None, base_factory: Incomplete | None = None, params: Incomplete | None = None): ...
    def next_sequence(self): ...
    def reset_sequence(self, value: Incomplete | None = None, force: bool = False) -> None: ...
    def prepare_arguments(self, attributes): ...
    def instantiate(self, step, args, kwargs): ...
    def use_postgeneration_results(self, step, instance, results) -> None: ...
    def get_model_class(self): ...

class _Counter:
    seq: Incomplete
    def __init__(self, seq) -> None: ...
    def next(self): ...
    def reset(self, next_value: int = 0) -> None: ...

class BaseFactory(Generic[T]):
    UnknownStrategy = errors.UnknownStrategy
    UnsupportedStrategy = errors.UnsupportedStrategy
    def __new__(cls, *args, **kwargs) -> None: ...
    @classmethod
    def reset_sequence(cls, value: Incomplete | None = None, force: bool = False) -> None: ...
    @classmethod
    def build(cls, **kwargs) -> T: ...
    @classmethod
    def build_batch(cls, size: int, **kwargs) -> list[T]: ...
    @classmethod
    def create(cls, **kwargs) -> T: ...
    @classmethod
    def create_batch(cls, size: int, **kwargs) -> list[T]: ...
    @classmethod
    def stub(cls, **kwargs): ...
    @classmethod
    def stub_batch(cls, size, **kwargs): ...
    @classmethod
    def generate(cls, strategy, **kwargs): ...
    @classmethod
    def generate_batch(cls, strategy, size, **kwargs): ...
    @classmethod
    def simple_generate(cls, create, **kwargs): ...
    @classmethod
    def simple_generate_batch(cls, create, size, **kwargs): ...

class Factory(BaseFactory[T], metaclass=FactoryMetaClass):
    AssociatedClassError: type[Exception]
    class Meta(BaseMeta): ...

class StubObject:
    def __init__(self, **kwargs) -> None: ...

class StubFactory(Factory):
    class Meta:
        strategy: Incomplete
        model = StubObject
    @classmethod
    def build(cls, **kwargs): ...
    @classmethod
    def create(cls, **kwargs) -> None: ...

class BaseDictFactory(Factory):
    class Meta:
        abstract: bool

class DictFactory(BaseDictFactory):
    class Meta:
        model = dict

class BaseListFactory(Factory):
    class Meta:
        abstract: bool

class ListFactory(BaseListFactory):
    class Meta:
        model = list

def use_strategy(new_strategy): ...
